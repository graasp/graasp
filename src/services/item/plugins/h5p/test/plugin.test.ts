import { randomUUID } from 'crypto';
import { Options, compare as dircompare, fileCompareHandlers } from 'dir-compare';
import fs from 'fs';
import fsp from 'fs/promises';
import { StatusCodes } from 'http-status-codes';
import path from 'path';

import { FastifyInstance, LightMyRequestResponse } from 'fastify';

import { H5PItemExtra, H5PItemType, ItemType } from '@graasp/sdk';

import build from '../../../../../../test/app';
import { H5P_LOCAL_CONFIG, H5P_PATH_PREFIX, H5P_TEMP_DIR } from '../../../../../utils/config';
import { Member } from '../../../../member/entities/member';
import { Item } from '../../../entities/Item';
import { H5P_FILE_DOT_EXTENSION } from '../constants';
import { H5PImportError, H5PInvalidFileError } from '../errors';
import { H5PService } from '../service';
import { H5P_PACKAGES } from './fixtures';
import { expectH5PFiles, injectH5PImport } from './helpers';

const H5P_ACCORDION_FILENAME = path.basename(H5P_PACKAGES.ACCORDION.path);

const MOCK_ITEM = new Item();
const MOCK_MEMBER = new Member();

describe('Service plugin', () => {
  let app: FastifyInstance;

  beforeEach(async () => {
    app = (await build()).app;
  });

  afterEach(async () => {
    await app.close();
  });

  it('decorates the fastify instance with h5p service', () => {
    expect(app.h5p).toBeDefined();
    expect(app.h5p instanceof H5PService).toBeTruthy();
  });

  describe('Upload valid .h5p package', () => {
    let res: LightMyRequestResponse,
      json: H5PItemType,
      contentId: string,
      expectedExtra: H5PItemExtra,
      expectedMetadata: Partial<H5PItemType>;

    beforeEach(async () => {
      res = await injectH5PImport(app);

      json = res.json();

      // contentId is generated by the server so we have to retrieve it from response
      contentId = json.extra.h5p.contentId;

      expectedExtra = {
        h5p: {
          contentId,
          h5pFilePath: `${contentId}/${H5P_ACCORDION_FILENAME}`,
          contentFilePath: `${contentId}/content`,
        },
      };

      expectedMetadata = {
        name: H5P_ACCORDION_FILENAME,
        type: ItemType.H5P,
        extra: expectedExtra,
      };
    });

    it('returns the created item object', () => {
      expect(res.statusCode).toEqual(StatusCodes.OK);
      expect(json).toEqual({
        ...MOCK_ITEM,
        ...expectedMetadata,
      });
    });

    // TODO: enable back when item memberships service is decorated
    /*
    it('validates the write permission in parent if it exists', () => {
      const getItem = jest.spyOn(build.app.itemMemberships.service, 'getInherited');
      getItem.mockImplementationOnce(() => {
        throw new MemberCannotAccess();
      });

      expect(json).toEqual({});
    });
    */

    it('extracts the files correctly', async () => {
      const { storageRootPath } = H5P_LOCAL_CONFIG.local;
      await expectH5PFiles(H5P_PACKAGES.ACCORDION, storageRootPath, H5P_PATH_PREFIX, contentId);
    });

    it('removes the temporary extraction folder', async () => {
      if (!H5P_TEMP_DIR) {
        throw new Error(
          `Cannot test for temp folder: ${H5P_TEMP_DIR}. Make sure that the H5P_TEMP_DIR env var is set in test mode`,
        );
      }
      const contents = await fsp.readdir(H5P_TEMP_DIR);
      expect(contents.length).toEqual(0);
    });
  });

  describe('Error handling', () => {
    it('returns error on invalid H5P package', async () => {
      const res = await injectH5PImport(app, { filePath: H5P_PACKAGES.BOGUS_EMPTY.path });
      expect(res.statusCode).toEqual(StatusCodes.BAD_REQUEST);
      expect(res.json()).toEqual(new H5PInvalidFileError('Missing h5p.json manifest file'));
    });

    it('returns error and deletes extracted files on item creation failure', async () => {
      const createItem = jest.spyOn(app.items.service, 'post');
      createItem.mockImplementationOnce(() => {
        throw new Error('mock error');
      });

      const res = await injectH5PImport(app);
      expect(res.statusCode).toEqual(StatusCodes.INTERNAL_SERVER_ERROR);
      expect(res.json()).toEqual(new H5PImportError());

      const { storageRootPath } = H5P_LOCAL_CONFIG.local;
      if (!H5P_TEMP_DIR) {
        throw new Error(
          `Cannot test for temp folder: ${H5P_TEMP_DIR}. Make sure that the H5P_TEMP_DIR env var is set in test mode`,
        );
      }
      const extractionDirContents = await fsp.readdir(H5P_TEMP_DIR);
      const storageDirContents = await fsp.readdir(
        path.join(...([storageRootPath, H5P_PATH_PREFIX].filter((e) => e) as string[])),
      );
      expect(extractionDirContents.length).toEqual(0);
      expect(storageDirContents.length).toEqual(0);
    });

    it('skips invalid file extensions', async () => {
      const res = await injectH5PImport(app, { filePath: H5P_PACKAGES.BOGUS_WRONG_EXTENSION.path });
      const item = res.json();
      const contentId = item.extra.h5p.contentId;
      const { storageRootPath } = H5P_LOCAL_CONFIG.local;
      await expectH5PFiles(
        H5P_PACKAGES.BOGUS_WRONG_EXTENSION,
        storageRootPath,
        H5P_PATH_PREFIX,
        contentId,
      );

      const maliciousFolder = path.join(
        ...[storageRootPath, H5P_PATH_PREFIX, contentId, 'content', 'foo'].filter((e) => e),
      );
      expect(fs.existsSync(maliciousFolder)).toBeTruthy();
      // only .txt should be left inside
      const contents = await fsp.readdir(maliciousFolder);
      expect(contents.length).toEqual(1);
      expect(contents.includes('valid.txt')).toBeTruthy();
    });
  });
});

describe('Hooks', () => {
  let item: H5PItemType;
  let app: FastifyInstance;

  beforeEach(async () => {
    // create a fresh app at each test
    app = (await build()).app;

    // create an H5P item through import
    const res = await injectH5PImport(app, { filePath: H5P_PACKAGES.ACCORDION.path });
    expect(res.statusCode).toEqual(StatusCodes.OK);
    item = res.json();
    const contentId = item.extra.h5p.contentId;
    await expectH5PFiles(
      H5P_PACKAGES.ACCORDION,
      H5P_LOCAL_CONFIG.local.storageRootPath,
      H5P_PATH_PREFIX,
      contentId,
    );
  });

  afterEach(async () => {
    await app.close();
  });

  it('deletes H5P assets on item delete', async () => {
    const contentId = item.extra.h5p.contentId;

    // delete item
    await app.inject({
      method: 'DELETE',
      url: `/items/${item.id}`,
    });

    // H5P folder should now be deleted
    const h5pFolder = path.join(
      ...([H5P_LOCAL_CONFIG.local.storageRootPath, H5P_PATH_PREFIX, contentId].filter(
        (e) => e,
      ) as string[]),
    );
    expect(fs.existsSync(h5pFolder)).toBeFalsy();
  });

  it('does not execute handler when item is not of type H5P', async () => {
    const contentId = item.extra.h5p.contentId;

    // delete item
    await app.inject({
      method: 'DELETE',
      url: `/items/${item.id}`,
    });

    // H5P folder should not be deleted
    const h5pFolder = path.join(
      ...([H5P_LOCAL_CONFIG.local.storageRootPath, H5P_PATH_PREFIX, contentId].filter(
        (e) => e,
      ) as string[]),
    );
    expect(fs.existsSync(h5pFolder)).toBeTruthy();
  });

  it('copies H5P assets on item copy', async () => {
    const contentId = item.extra.h5p.contentId;

    // copy item
    await app.inject({
      method: 'POST',
      url: 'items/copy',
      query: {
        id: [item.id],
      },
      payload: {
        parentId: randomUUID(),
      },
    });

    // H5P folder should now be copied
    const h5pBucket = path.join(
      ...([H5P_LOCAL_CONFIG.local.storageRootPath, H5P_PATH_PREFIX].filter((e) => e) as string[]),
    );
    const h5pFolders = await fsp.readdir(h5pBucket);
    expect(h5pFolders.length).toEqual(2);
    expect(h5pFolders.includes(contentId));
    const otherId = h5pFolders.find((e) => e !== contentId)!; // the above line ensures exists

    // expected name of the copy
    const H5P_ACCORDION_COPY_FILENAME = `${path.basename(
      H5P_ACCORDION_FILENAME,
      H5P_FILE_DOT_EXTENSION,
    )}-1${H5P_FILE_DOT_EXTENSION}`;
    const originalPath = path.join(h5pBucket, contentId, H5P_ACCORDION_FILENAME);
    const copyPath = path.join(h5pBucket, otherId, H5P_ACCORDION_COPY_FILENAME);
    const originalStats = await fsp.stat(originalPath);
    const copyStats = await fsp.stat(copyPath);

    const defaultFileCompare = fileCompareHandlers.defaultFileCompare.compareAsync;
    const customFileCompare = (
      path1: string,
      stat1: fs.Stats,
      path2: string,
      stat2: fs.Stats,
      options: Options,
    ) => {
      if (path1 === originalPath) {
        return defaultFileCompare(path1, stat1, copyPath, copyStats, options);
      } else if (path2 === originalPath) {
        return defaultFileCompare(copyPath, copyStats, path2, stat2, options);
      } else if (path1 === copyPath) {
        return defaultFileCompare(path1, stat1, originalPath, originalStats, options);
      } else if (path2 === copyPath) {
        return defaultFileCompare(originalPath, originalStats, path2, stat2, options);
      } else {
        return defaultFileCompare(path1, stat1, path2, stat2, options);
      }
    };

    const dirDiff = await dircompare(originalPath, copyPath, {
      compareContent: true,
      compareFileAsync: customFileCompare,
    });
    expect(dirDiff.same).toBeTruthy();
  });

  it('does not execute handler when item is not of type H5P', async () => {
    // copy item
    await app.inject({
      method: 'POST',
      url: 'items/copy',
      query: {
        id: [item.id],
      },
      payload: {
        parentId: randomUUID(),
      },
    });
    // H5P folder should not be copied
    const h5pBucket = path.join(
      ...([H5P_LOCAL_CONFIG.local.storageRootPath, H5P_PATH_PREFIX].filter((e) => e) as string[]),
    );
    const h5pFolders = await fsp.readdir(h5pBucket);
    expect(h5pFolders.length).toEqual(1);
  });
});
