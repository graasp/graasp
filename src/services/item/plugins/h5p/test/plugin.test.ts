import { Options, compare as dircompare, fileCompareHandlers } from 'dir-compare';
import fs from 'fs';
import fsp from 'fs/promises';
import { StatusCodes } from 'http-status-codes';
import path from 'path';

import { LightMyRequestResponse } from 'fastify';

import { H5PItemExtra, H5PItemType, ItemType } from '@graasp/sdk';

import { Handler, default as HookManager } from '../../../../../utils/hook';
import { buildRepositories } from '../../../../../utils/repositories';
import { Member } from '../../../../member/entities/member';
import { Item } from '../../../entities/Item';
import ItemService from '../../../service';
import { H5P_FILE_DOT_EXTENSION } from '../constants';
import { H5PImportError, H5PInvalidFileError } from '../errors';
import { H5PService } from '../service';
import { BuildAppType, buildApp, expectH5PFiles, injectH5PImport } from './app';
import { H5P_PACKAGES } from './fixtures';

const H5P_ACCORDION_FILENAME = path.basename(H5P_PACKAGES.ACCORDION.path);

const MOCK_ITEM = new Item();
const MOCK_MEMBER = new Member();

describe('Service plugin', () => {
  let build: BuildAppType;

  beforeEach(async () => {
    build = await buildApp();
    await build.registerH5PPlugin();
  });

  afterEach(async () => {
    await build.cleanup();
  });

  it('decorates the fastify instance with h5p service', () => {
    const { app } = build;
    expect(app.h5p).toBeDefined();
    expect(app.h5p instanceof H5PService).toBeTruthy();
  });

  describe('Upload valid .h5p package', () => {
    let res: LightMyRequestResponse,
      json: H5PItemType,
      contentId: string,
      expectedExtra: H5PItemExtra,
      expectedMetadata: Partial<H5PItemType>;

    beforeEach(async () => {
      const { app } = build;

      res = await injectH5PImport(app);

      json = res.json();

      // contentId is generated by the server so we have to retrieve it from response
      contentId = json.extra.h5p.contentId;

      expectedExtra = {
        h5p: {
          contentId,
          h5pFilePath: `${contentId}/${H5P_ACCORDION_FILENAME}`,
          contentFilePath: `${contentId}/content`,
        },
      };

      expectedMetadata = {
        name: H5P_ACCORDION_FILENAME,
        type: ItemType.H5P,
        extra: expectedExtra,
      };
    });

    it('returns the created item object', () => {
      expect(res.statusCode).toEqual(StatusCodes.OK);
      expect(json).toEqual({
        ...MOCK_ITEM,
        ...expectedMetadata,
      });
    });

    // TODO: enable back when item memberships service is decorated
    /*
    it('validates the write permission in parent if it exists', () => {
      const getItem = jest.spyOn(build.app.itemMemberships.service, 'getInherited');
      getItem.mockImplementationOnce(() => {
        throw new MemberCannotAccess();
      });

      expect(json).toEqual({});
    });
    */

    it('extracts the files correctly', async () => {
      const { storageRootPath, pathPrefix } = build.options;
      await expectH5PFiles(H5P_PACKAGES.ACCORDION, storageRootPath, pathPrefix, contentId);
    });

    it('removes the temporary extraction folder', async () => {
      const { extractionRootPath } = build.options;
      const contents = await fsp.readdir(extractionRootPath);
      expect(contents.length).toEqual(0);
    });
  });

  describe('Error handling', () => {
    it('returns error on invalid H5P package', async () => {
      const { app } = build;
      const res = await injectH5PImport(app, { filePath: H5P_PACKAGES.BOGUS_EMPTY.path });
      expect(res.statusCode).toEqual(StatusCodes.BAD_REQUEST);
      expect(res.json()).toEqual(new H5PInvalidFileError('Missing h5p.json manifest file'));
    });

    it('returns error and deletes extracted files on item creation failure', async () => {
      const { app } = build;
      const createItem = jest.spyOn(build.app.items.service, 'post');
      createItem.mockImplementationOnce(() => {
        throw new Error('mock error');
      });

      const res = await injectH5PImport(app);
      expect(res.statusCode).toEqual(StatusCodes.INTERNAL_SERVER_ERROR);
      expect(res.json()).toEqual(new H5PImportError());

      const { extractionRootPath, storageRootPath, pathPrefix } = build.options;
      const extractionDirContents = await fsp.readdir(extractionRootPath);
      const storageDirContents = await fsp.readdir(path.join(storageRootPath, pathPrefix));
      expect(extractionDirContents.length).toEqual(0);
      expect(storageDirContents.length).toEqual(0);
    });

    it('skips invalid file extensions', async () => {
      const { app } = build;
      const res = await injectH5PImport(app, { filePath: H5P_PACKAGES.BOGUS_WRONG_EXTENSION.path });
      const item = res.json();
      const contentId = item.extra.h5p.contentId;
      const { storageRootPath, pathPrefix } = build.options;
      await expectH5PFiles(
        H5P_PACKAGES.BOGUS_WRONG_EXTENSION,
        storageRootPath,
        pathPrefix,
        contentId,
      );

      const maliciousFolder = path.join(storageRootPath, pathPrefix, contentId, 'content', 'foo');
      expect(fs.existsSync(maliciousFolder)).toBeTruthy();
      // only .txt should be left inside
      const contents = await fsp.readdir(maliciousFolder);
      expect(contents.length).toEqual(1);
      expect(contents.includes('valid.txt')).toBeTruthy();
    });
  });
});

describe('Hooks', () => {
  let build: BuildAppType;

  let item: H5PItemType;

  type GetGenericOf<C extends HookManager<any>> = C extends HookManager<infer T> ? T : unknown;
  type DeleteHandler = Handler<GetGenericOf<ItemService['hooks']>['delete']['post']>;
  type CopyHandler = Handler<GetGenericOf<ItemService['hooks']>['copy']['post']>;

  let onDelete: DeleteHandler;
  let onCopy: CopyHandler;

  beforeEach(async () => {
    // create a fresh app at each test
    build = await buildApp();

    // setup handler storage to execute it when we will simulate an item delete

    const onDeleteStore = new Promise<DeleteHandler>((resolve, reject) => {
      jest
        .spyOn<ItemService['hooks'], 'setPostHook'>(build.app.items.service.hooks, 'setPostHook')
        .mockImplementation((event: string, handler: DeleteHandler) => {
          if (event === 'delete') {
            resolve(handler);
          }
        });
    });
    // setup handler storage to execute it when we will simulate an item copy

    const onCopyStore = new Promise<CopyHandler>((resolve, reject) => {
      jest
        .spyOn<ItemService['hooks'], 'setPostHook'>(build.app.items.service.hooks, 'setPostHook')
        .mockImplementation((event, handler) => {
          if (event === 'copy') {
            resolve(handler);
          }
        });
    });

    // handlers be saved after registerH5PPlugin
    await build.registerH5PPlugin();

    // create an H5P item through import
    const res = await injectH5PImport(build.app, { filePath: H5P_PACKAGES.ACCORDION.path });
    expect(res.statusCode).toEqual(StatusCodes.OK);
    item = res.json();
    const contentId = item.extra.h5p.contentId;
    const { storageRootPath, pathPrefix } = build.options;
    await expectH5PFiles(H5P_PACKAGES.ACCORDION, storageRootPath, pathPrefix, contentId);

    onDelete = await onDeleteStore;
    onCopy = await onCopyStore;
  });

  afterEach(async () => {
    await build.cleanup();
  });

  it('deletes H5P assets on item delete', async () => {
    const { storageRootPath, pathPrefix } = build.options;
    const contentId = item.extra.h5p.contentId;

    // simulate an item delete
    expect(onDelete).toBeDefined();
    await onDelete(MOCK_MEMBER, buildRepositories(), { item: MOCK_ITEM });

    // H5P folder should now be deleted
    const h5pFolder = path.join(storageRootPath, pathPrefix, contentId);
    expect(fs.existsSync(h5pFolder)).toBeFalsy();
  });

  it('does not execute handler when item is not of type H5P', async () => {
    const { storageRootPath, pathPrefix } = build.options;
    const contentId = item.extra.h5p.contentId;

    // simulate an item delete with a non-H5P item
    expect(onDelete).toBeDefined();
    await onDelete(MOCK_MEMBER, buildRepositories(), { item: MOCK_ITEM });

    // H5P folder should not be deleted
    const h5pFolder = path.join(storageRootPath, pathPrefix, contentId);
    expect(fs.existsSync(h5pFolder)).toBeTruthy();
  });

  it('copies H5P assets on item copy', async () => {
    const { storageRootPath, pathPrefix } = build.options;
    const contentId = item.extra.h5p.contentId;

    // simulate an item copy
    expect(onCopy).toBeDefined();
    await onCopy(MOCK_MEMBER, buildRepositories(), { original: MOCK_ITEM, copy: item as Item });

    // H5P folder should now be copied
    const h5pBucket = path.join(storageRootPath, pathPrefix);
    const h5pFolders = await fsp.readdir(h5pBucket);
    expect(h5pFolders.length).toEqual(2);
    expect(h5pFolders.includes(contentId));
    const otherId = h5pFolders.find((e) => e !== contentId)!; // the above line ensures exists

    // expected name of the copy
    const H5P_ACCORDION_COPY_FILENAME = `${path.basename(
      H5P_ACCORDION_FILENAME,
      H5P_FILE_DOT_EXTENSION,
    )}-1${H5P_FILE_DOT_EXTENSION}`;
    const originalPath = path.join(h5pBucket, contentId, H5P_ACCORDION_FILENAME);
    const copyPath = path.join(h5pBucket, otherId, H5P_ACCORDION_COPY_FILENAME);
    const originalStats = await fsp.stat(originalPath);
    const copyStats = await fsp.stat(copyPath);

    const defaultFileCompare = fileCompareHandlers.defaultFileCompare.compareAsync;
    const customFileCompare = (
      path1: string,
      stat1: fs.Stats,
      path2: string,
      stat2: fs.Stats,
      options: Options,
    ) => {
      if (path1 === originalPath) {
        return defaultFileCompare(path1, stat1, copyPath, copyStats, options);
      } else if (path2 === originalPath) {
        return defaultFileCompare(copyPath, copyStats, path2, stat2, options);
      } else if (path1 === copyPath) {
        return defaultFileCompare(path1, stat1, originalPath, originalStats, options);
      } else if (path2 === copyPath) {
        return defaultFileCompare(originalPath, originalStats, path2, stat2, options);
      } else {
        return defaultFileCompare(path1, stat1, path2, stat2, options);
      }
    };

    const dirDiff = await dircompare(originalPath, copyPath, {
      compareContent: true,
      compareFileAsync: customFileCompare,
    });
    expect(dirDiff.same).toBeTruthy();
  });

  it('does not execute handler when item is not of type H5P', async () => {
    const { storageRootPath, pathPrefix } = build.options;

    // simulate an item copy of non-H5P item
    expect(onCopy).toBeDefined();
    await onCopy(MOCK_MEMBER, buildRepositories(), { original: MOCK_ITEM, copy: item as Item });

    // H5P folder should not be copied
    const h5pBucket = path.join(storageRootPath, pathPrefix);
    const h5pFolders = await fsp.readdir(h5pBucket);
    expect(h5pFolders.length).toEqual(1);
  });

  it('throws if item name is missing', async () => {
    // simulate an item copy of bogus item
    expect(onCopy).toBeDefined();
    await expect(
      onCopy(MOCK_MEMBER, buildRepositories(), {
        original: MOCK_ITEM,
        copy: { ...item, name: undefined } as unknown as Item,
      }),
    ).rejects.toThrow('Invalid state: missing previous H5P item name on copy');
  });

  it('throws if item h5p extra is missing', async () => {
    // simulate an item copy of bogus item
    expect(onCopy).toBeDefined();
    await expect(
      onCopy(MOCK_MEMBER, buildRepositories(), {
        original: MOCK_ITEM,
        copy: { ...item, extra: undefined } as unknown as Item,
      }),
    ).rejects.toThrow('Invalid state: missing previous H5P item extra on copy');
  });
});
