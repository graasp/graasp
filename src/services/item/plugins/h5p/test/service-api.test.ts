import { Options, compare as dircompare, fileCompareHandlers } from 'dir-compare';
import fs from 'fs';
import fsp from 'fs/promises';
import { StatusCodes } from 'http-status-codes';
import LightMyRequest from 'light-my-request';
import path from 'path';
import { createMock } from 'ts-auto-mock';

import {
  Actor,
  H5PExtra,
  Item,
  PostHookHandlerType,
  PreHookHandlerType,
  TaskRunner,
  TaskStatus,
} from '@graasp/sdk';

import { H5P_FILE_DOT_EXTENSION, H5P_ITEM_TYPE } from '../src/constants';
import { H5PImportError, InvalidH5PFileError } from '../src/errors';
import { H5PService } from '../src/service';
import {
  BuildAppType,
  CoreSpiesType,
  buildApp,
  expectH5PFiles,
  injectH5PImport,
  mockCoreServices,
} from './app';
import { H5P_PACKAGES, MOCK_ITEM, MOCK_MEMBER, mockParentId, mockTask } from './fixtures';

const H5P_ACCORDION_FILENAME = path.basename(H5P_PACKAGES.ACCORDION.path);

describe('Service plugin', () => {
  let build: BuildAppType;

  /* spies */
  let spies: CoreSpiesType;

  beforeEach(async () => {
    build = await buildApp();
    await build.registerH5PPlugin();
    spies = mockCoreServices(build);
  });

  afterEach(async () => {
    await build.cleanup();
  });

  it('decorates the fastify instance with h5p service', () => {
    const { app } = build;
    expect(app.h5p).toBeDefined();
    expect(app.h5p instanceof H5PService).toBeTruthy();
  });

  describe('Upload valid .h5p package', () => {
    let res: LightMyRequest.Response,
      json: Item<H5PExtra>,
      contentId: string,
      expectedExtra: H5PExtra,
      expectedMetadata: Partial<Item<H5PExtra>>;

    beforeEach(async () => {
      const { app } = build;

      res = await injectH5PImport(app);

      json = res.json();

      // contentId is generated by the server so we have to retrieve it from response
      contentId = json.extra.h5p.contentId;

      expectedExtra = {
        h5p: {
          contentId,
          h5pFilePath: `${contentId}/${H5P_ACCORDION_FILENAME}`,
          contentFilePath: `${contentId}/content`,
        },
      };

      expectedMetadata = {
        name: H5P_ACCORDION_FILENAME,
        type: H5P_ITEM_TYPE,
        extra: expectedExtra,
      };
    });

    it('returns the created item object', () => {
      expect(res.statusCode).toEqual(StatusCodes.OK);
      expect(json).toEqual({
        ...MOCK_ITEM,
        ...expectedMetadata,
      });
    });

    it('validates the write permission in parent if it exists', () => {
      expect(spies.getItem).toHaveBeenCalledTimes(1);
      expect(spies.getItem).toHaveBeenCalledWith(MOCK_MEMBER, mockParentId);

      expect(spies.getMembership).toHaveBeenCalledTimes(1);
      expect(spies.getMembership).toHaveBeenCalledWith(MOCK_MEMBER);

      const usedGetItemTask = spies.getItem.mock.results[0].value;
      const usedGetMembershipTask = spies.getMembership.mock.results[0].value;
      expect(spies.runSingleSequence).toHaveBeenCalledWith([
        usedGetItemTask,
        usedGetMembershipTask,
      ]);
    });

    it('extracts the files correctly', async () => {
      const { storageRootPath, pathPrefix } = build.options;
      await expectH5PFiles(H5P_PACKAGES.ACCORDION, storageRootPath, pathPrefix, contentId);
    });

    it('creates the item through the item service', () => {
      expect(spies.createItem).toHaveBeenCalledTimes(1);
      expect(spies.createItem).toHaveBeenCalledWith(MOCK_MEMBER, expectedMetadata, mockParentId);

      const usedCreateItemSequence = spies.createItem.mock.results[0].value;
      expect(spies.runSingleSequence).toHaveBeenCalledWith(usedCreateItemSequence);
    });

    it('removes the temporary extraction folder', async () => {
      const { extractionRootPath } = build.options;
      const contents = await fsp.readdir(extractionRootPath);
      expect(contents.length).toEqual(0);
    });
  });

  describe('Error handling', () => {
    it('returns error on invalid H5P package', async () => {
      const { app } = build;
      const res = await injectH5PImport(app, { filePath: H5P_PACKAGES.BOGUS_EMPTY.path });
      expect(res.statusCode).toEqual(StatusCodes.BAD_REQUEST);
      expect(res.json()).toEqual(new InvalidH5PFileError('Missing h5p.json manifest file'));
    });

    it('returns error and deletes extracted files on item creation failure', async () => {
      const { app } = build;
      spies.createItem.mockReturnValueOnce([
        mockTask<unknown>(
          'MockFailCreateItemTask',
          MOCK_MEMBER,
          undefined,
          TaskStatus.NEW,
          (handler, log) => {
            throw new Error('mock-error');
          },
        ),
      ]);

      const res = await injectH5PImport(app);
      expect(res.statusCode).toEqual(StatusCodes.INTERNAL_SERVER_ERROR);
      expect(res.json()).toEqual(new H5PImportError());

      const { extractionRootPath, storageRootPath, pathPrefix } = build.options;
      const extractionDirContents = await fsp.readdir(extractionRootPath);
      const storageDirContents = await fsp.readdir(path.join(storageRootPath, pathPrefix));
      expect(extractionDirContents.length).toEqual(0);
      expect(storageDirContents.length).toEqual(0);
    });

    it('skips invalid file extensions', async () => {
      const { app } = build;
      const res = await injectH5PImport(app, { filePath: H5P_PACKAGES.BOGUS_WRONG_EXTENSION.path });
      const item = res.json();
      const contentId = item.extra.h5p.contentId;
      const { storageRootPath, pathPrefix } = build.options;
      await expectH5PFiles(
        H5P_PACKAGES.BOGUS_WRONG_EXTENSION,
        storageRootPath,
        pathPrefix,
        contentId,
      );

      const maliciousFolder = path.join(storageRootPath, pathPrefix, contentId, 'content', 'foo');
      expect(fs.existsSync(maliciousFolder)).toBeTruthy();
      // only .txt should be left inside
      const contents = await fsp.readdir(maliciousFolder);
      expect(contents.length).toEqual(1);
      expect(contents.includes('valid.txt')).toBeTruthy();
    });
  });
});

describe('Hooks', () => {
  /** we manually create a mock task runner to inject implementations */
  let taskRunner: TaskRunner<Actor>;

  let build: BuildAppType;
  let spies: CoreSpiesType;

  let item: Item<H5PExtra>;
  let onDelete: PostHookHandlerType<Item<H5PExtra>>;
  let onCopy: PostHookHandlerType<Partial<Item<H5PExtra>>>;

  beforeAll(() => {
    taskRunner = createMock<TaskRunner<Actor>>();
  });

  beforeEach(async () => {
    // create a fresh app at each test
    build = await buildApp({ services: { taskRunner } });
    spies = mockCoreServices(build);

    // setup handler storage to execute it when we will simulate an item delete
    const onDeleteStore = new Promise<PostHookHandlerType<Item<H5PExtra>>>((resolve, reject) => {
      spies.setTaskPostHookHandler.mockImplementation((taskName, handler) => {
        resolve(handler);
      });
    });
    // setup handler storage to execute it when we will simulate an item copy
    const onCopyStore = new Promise<PreHookHandlerType<Item<H5PExtra>>>((resolve, reject) => {
      spies.setTaskPreHookHandler.mockImplementation((taskName, handler) => {
        resolve(handler);
      });
    });

    // handlers be saved after registerH5PPlugin
    await build.registerH5PPlugin();

    // create an H5P item through import
    const res = await injectH5PImport(build.app, { filePath: H5P_PACKAGES.ACCORDION.path });
    expect(res.statusCode).toEqual(StatusCodes.OK);
    item = res.json();
    const contentId = item.extra.h5p.contentId;
    const { storageRootPath, pathPrefix } = build.options;
    await expectH5PFiles(H5P_PACKAGES.ACCORDION, storageRootPath, pathPrefix, contentId);

    onDelete = await onDeleteStore;
    onCopy = await onCopyStore;
  });

  afterEach(async () => {
    await build.cleanup();
  });

  it('deletes H5P assets on item delete', async () => {
    const { storageRootPath, pathPrefix } = build.options;
    const contentId = item.extra.h5p.contentId;

    // simulate an item delete
    expect(onDelete).toBeDefined();
    await onDelete(item, MOCK_MEMBER, { log: build.services.logger });

    // H5P folder should now be deleted
    const h5pFolder = path.join(storageRootPath, pathPrefix, contentId);
    expect(fs.existsSync(h5pFolder)).toBeFalsy();
  });

  it('does not execute handler when item is not of type H5P', async () => {
    const { storageRootPath, pathPrefix } = build.options;
    const contentId = item.extra.h5p.contentId;

    // simulate an item delete with a non-H5P item
    expect(onDelete).toBeDefined();
    await onDelete(MOCK_ITEM, MOCK_MEMBER, { log: build.services.logger });

    // H5P folder should not be deleted
    const h5pFolder = path.join(storageRootPath, pathPrefix, contentId);
    expect(fs.existsSync(h5pFolder)).toBeTruthy();
  });

  it('copies H5P assets on item copy', async () => {
    const { storageRootPath, pathPrefix } = build.options;
    const contentId = item.extra.h5p.contentId;

    // simulate an item copy
    expect(onCopy).toBeDefined();
    await onCopy(item, MOCK_MEMBER, { log: build.services.logger });

    // H5P folder should now be copied
    const h5pBucket = path.join(storageRootPath, pathPrefix);
    const h5pFolders = await fsp.readdir(h5pBucket);
    expect(h5pFolders.length).toEqual(2);
    expect(h5pFolders.includes(contentId));
    const otherId = h5pFolders.find((e) => e !== contentId)!; // the above line ensures exists

    // expected name of the copy
    const H5P_ACCORDION_COPY_FILENAME = `${path.basename(
      H5P_ACCORDION_FILENAME,
      H5P_FILE_DOT_EXTENSION,
    )}-1${H5P_FILE_DOT_EXTENSION}`;
    const originalPath = path.join(h5pBucket, contentId, H5P_ACCORDION_FILENAME);
    const copyPath = path.join(h5pBucket, otherId, H5P_ACCORDION_COPY_FILENAME);
    const originalStats = await fsp.stat(originalPath);
    const copyStats = await fsp.stat(copyPath);

    const defaultFileCompare = fileCompareHandlers.defaultFileCompare.compareAsync;
    const customFileCompare = (
      path1: string,
      stat1: fs.Stats,
      path2: string,
      stat2: fs.Stats,
      options: Options,
    ) => {
      if (path1 === originalPath) {
        return defaultFileCompare(path1, stat1, copyPath, copyStats, options);
      } else if (path2 === originalPath) {
        return defaultFileCompare(copyPath, copyStats, path2, stat2, options);
      } else if (path1 === copyPath) {
        return defaultFileCompare(path1, stat1, originalPath, originalStats, options);
      } else if (path2 === copyPath) {
        return defaultFileCompare(originalPath, originalStats, path2, stat2, options);
      } else {
        return defaultFileCompare(path1, stat1, path2, stat2, options);
      }
    };

    const dirDiff = await dircompare(originalPath, copyPath, {
      compareContent: true,
      compareFileAsync: customFileCompare,
    });
    expect(dirDiff.same).toBeTruthy();
  });

  it('does not execute handler when item is not of type H5P', async () => {
    const { storageRootPath, pathPrefix } = build.options;

    // simulate an item copy of non-H5P item
    expect(onCopy).toBeDefined();
    await onCopy(MOCK_ITEM, MOCK_MEMBER, { log: build.services.logger });

    // H5P folder should not be copied
    const h5pBucket = path.join(storageRootPath, pathPrefix);
    const h5pFolders = await fsp.readdir(h5pBucket);
    expect(h5pFolders.length).toEqual(1);
  });

  it('throws if item name is missing', async () => {
    // simulate an item copy of bogus item
    expect(onCopy).toBeDefined();
    await expect(
      onCopy({ ...item, name: undefined }, MOCK_MEMBER, {
        log: build.services.logger,
      }),
    ).rejects.toThrow('Invalid state: missing previous H5P item name on copy');
  });

  it('throws if item h5p extra is missing', async () => {
    // simulate an item copy of bogus item
    expect(onCopy).toBeDefined();
    await expect(
      onCopy({ ...item, extra: undefined }, MOCK_MEMBER, {
        log: build.services.logger,
      }),
    ).rejects.toThrow('Invalid state: missing previous H5P item extra on copy');
  });
});
