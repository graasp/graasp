# graasp-plugin-etherpad

This Fastify plugin implements the glue between the Etherpad external service and the Graasp platform. It exposes endpoints to manage Etherpad items in the Graasp object model, and provides authorization mapping between the permissions in Graasp to those in Etherpad.

The plugin communicates with the Etherpad server through the [HTTP API](https://etherpad.org/doc/v1.8.18/#index_http-api). You may find the [Etherpad documentation](https://etherpad.org/doc/v1.8.18/) useful as well.

We use our fork of the `etherpad-api` library at https://github.com/graasp/etherpad-api to facilitate the usage of the HTTP API in Typescript.

## Prerequisites

An instance of the Etherpad (lite) server should be available on the network to this plugin. The list of options to connect to it is available [here](types.ts).

#### A note on the Etherpad server API key

Note that the API key must be placed in the root folder of the Etherpad server deployment, see the related [documentation](https://etherpad.org/doc/v1.8.18/#index_authentication):

> Authentication works via a token that is sent with each request as a post parameter. There is a single token per Etherpad deployment. This token will be random string, generated by Etherpad at the first start. It will be saved in APIKEY.txt in the root folder of Etherpad. Only Etherpad and the requesting application knows this key. Token management will not be exposed through this API.

The key format must be a hex string of 64 characters (i.e. regex `[a-f\d]{64}`).

In the Graasp devcontainer, the key is bind-mounted from [this file](../../../../../.devcontainer/etherpad/devApiKey.txt) and the container is already available over the virtual network from the [docker-compose definition](../../../../../.devcontainer/docker-compose.yml).

In a production container environment, you should either bind-mount a secret key, or build your own etherpad image using the `etherpad/etherpad` image as base and write your own secret file, see the [Dockerfile](Dockerfile) as an example.

> Note: if you update the version of Etherpad, make sure that all relevant documentation is updated as well (e.g. search for `1.8.18` in the entire codebase).

## Usage

Register the plugin in a fastify instance as follows (make sure that the dependent services are decorated beforehand):

```ts
import etherpadPlugin from '<path>/<to>/etherpad';

fastify.register(etherpadPlugin, {
  url: ETHERPAD_URL,
  apiKey: ETHERPAD_API_KEY,
  publicUrl: ETHERPAD_PUBLIC_URL,
  cookieDomain: ETHERPAD_COOKIE_DOMAIN,
});
```

The plugin will attach new endpoints under the `/etherpad` prefix (relative to the mount point in the current router). E.g. assuming that the example above registers the plugin under the `/foobar` absolute route, then [service-api.ts](service-api.ts) mounts etherpad-specific routes at absolute paths `/foobar/etherpad/create`, `/foobar/view/:itemid`, etc.

## Permissions mapping

We need to map the Graasp permissions to Etherpad constructs. In Graasp, we represent each Etherpad by a corresponding Etherpad item.

### Builder mode

In the Builder view, the permissions should follow the user membership on the item. Note the special case when an item is public and the user is not logged in, it should still be readable.

> Header row: item visibility, first column: user permission

|            | private   |  public   |
| ---------- | --------- | --------- |
| logged out | none      | read pad  |
| read       | read pad  | read pad  |
| write      | write pad | write pad |
| admin      | write pad | write pad |

Note that the ability "read pad" should also enforce that a user **cannot** edit the pad, e.g. by manually constructing an URL.

> Depending on user needs, it may be interesting to set that public pads (i.e. which item is public) are always writable in Builder, even for logged out users and users that only have a read permission

### Player mode

In the Player view, the pad is (currently) always shown in read-only mode. This may be subject to change in the future, depending on user needs, in which case the mapping should be carefuly redesigned not to leak editable pads to unauthorized users.

> Header row: item visibility, first column: user permission

|            | private  |  public  |
| ---------- | -------- | -------- |
| logged out | read pad | read pad |
| read       | read pad | read pad |
| write      | read pad | read pad |
| admin      | read pad | read pad |

Etherpad exposes the following constructs to manage access to pads:

#### Environment variables

- [`REQUIRE_SESSION`](https://etherpad.org/doc/v1.8.18/#index_advanced):

  > If this option is enabled, a user must have a session to access pads. This effectively allows only group pads to be accessed.

  Note that we **cannot** use this option because we still want some pads to be publicly accessible (public etherpad items should still be at least readable to anyone, including logged out users).

- [`EDIT_ONLY`](https://etherpad.org/doc/v1.8.18/#index_advanced):

  > Users may edit pads but not create new ones. Pad creation is only via the API. This applies both to group pads and regular pads.

  We enable this option since it ensures that only the Graasp server will perform pad management

#### Groups and sessions

> Please read the following sections of the Etherpad documentation:
>
> - [Overview](https://etherpad.org/doc/v1.8.18/#index_overview)
> - [Data types](https://etherpad.org/doc/v1.8.18/#index_data-types)
> - [Groups](https://etherpad.org/doc/v1.8.18/#index_groups)
> - [Authors](https://etherpad.org/doc/v1.8.18/#index_author)
> - [Sessions](https://etherpad.org/doc/v1.8.18/#index_session)
> - [Pads](https://etherpad.org/doc/v1.8.18/#index_pad)
> - [Cookies](https://etherpad.org/doc/v1.8.18/#index_cookies)

![](https://i.imgur.com/d0nWp.png)

> A pad ID is either the the string of the groupID concatenated with the pad name separated by a dollar sign (e.g. `g.0123456789abcdef$foobar`) or a read only pad ID (e.g. `r.0123456789abcdef`).

Since the granularity of permissions in Graasp is at the item level, we map permissions as follows:

- Each Etherpad item in Graasp is mapped to an Etherpad group (the `groupMapper` is assigned a unique random identifier) which will contain a single pad.
- Each Graasp member which accesses to an Etherpad item is assigned an Etherpad author (the `authorMapper` is assigned the member id)
- Sessions are hence allocated between authors and groups, effectively mapping Graasp members to Graasp Etherpad items.
- In Etherpad, permission is represented by a session (which is stored in a single cookie) **as well as the `padID`**. A user may be given the actual ` padID` with the session, which effectively grants him write permissions on the pad, or a special `readOnlyID` for a given `padID` which only grants read permissions. **It is up to the Graasp back-end and front-ends to never expose both to unpriviliged users**, i.e. a user which does not have at least write permission should _never_ see the actual `padID`.

## Sequence diagrams

> Note: if you're reading this file from VSCode, we recommend installing the [Markdown Preview Mermaid Support](https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid) extension and opening the [Markdown Preview view](https://code.visualstudio.com/docs/languages/markdown#_markdown-preview).

The following operations are implemented on endpoints:

### Create an etherpad item

```mermaid
sequenceDiagram
    Client browser ->> Graasp back-end: POST /etherpad/create?parentId <br> { name }
    Note over Graasp back-end: Generate unique <br> { padName }
    Graasp back-end ->> Etherpad server: createGroupIfNotExistsFor <br> { groupMapper: padName }
    Etherpad server ->> Graasp back-end:  { groupID }
    Graasp back-end ->> Etherpad server: createGroupPad <br> { groupID, padName }
    Etherpad server ->> Graasp back-end: ok
    Note over Graasp back-end: Create etherpad item <br> { groupID, padName }
    Graasp back-end ->> Client browser: Etherpad item
```

### View an etherpad

```mermaid
sequenceDiagram
    Client browser ->> Graasp back-end: GET /etherpad/view/:itemId?mode
    Note over Graasp back-end: Get item from service containing { padID, groupID }
    Note over Graasp back-end: Validate permission, otherwise <br> fallback to read mode
    alt mode = read
        Graasp back-end ->> Etherpad server: getReadonlyID { padID }
        Etherpad server ->> Graasp back-end: { readOnlyID }
        note over Graasp back-end: construct padUrl from readOnlyID
    else mode = write
        note over Graasp back-end: construct padUrl from padID
    end
    Graasp back-end ->> Etherpad server: createAuthorIfNotExistsFor <br> { authorMapper: member.id, name: member.name }
    Etherpad server ->> Graasp back-end: { authorID }
    Note over Graasp back-end: Compute a session expiration
    Graasp back-end ->> Etherpad server: createSession <br> { authorID, groupID, validUntil: expiration }
    Etherpad server ->> Graasp back-end: { sessionID }
    Graasp back-end ->> Etherpad server: listSessionsOfAuthor <br> { authorID }
    Etherpad server ->> Graasp back-end: sessions
    Note over Graasp back-end: Compute cookie containing all valid sessions
    par asynchronous cleanup
        loop for all expired sessions
            Graasp back-end ->> Etherpad server: deleteSession <br> { sessionID }
        end
    and
        Graasp back-end ->> Client browser: { padUrl } <br> Set cookie header with valid sessions
    end
```

> **Note about the session cookie**
>
> The sessions cookie has several constraints:
>
> - It must be set to the public URL's domain of the etherpad server
> - It must be named `sessionID` (this is unfortunately currently [not customizable](https://github.com/ether/etherpad-lite/issues/664))
> - It cannot be signed or set to `httpOnly` because the Etherpad server does not support these options (authentication will not work)
> - It is unique for all valid sessions, which implies the following:
>   - The cookie expiration should be set to the expiration of the session with the longest lifespan (usually the latest on read)
>   - The cookie value must be set to the concatenation of all valid session strings, separated by commas
>   - It is up to the Graasp implementation to manage and cleanup expired sessions (fortunately the Etherpad server manages the storage of existing sessions)
>   - Although there is no specification for the size of cookies, modern browsers will limit the size of the value to 1024 bytes (see [constants.ts](constants.ts)). This means that only the last `floor(1024/19)` valid sessions can be stored in the cookie and it is hence the max number of concurrent etherpads that can be opened on a given device.
>   - Since the cookie needs to contain all valid sessions cumulatively, there cannot be concurrent requests from the front-ends: otherwise, a race condition appears where the last response received by the client with a cookie will win, even if it isn't the last generated one containing all the concurrent sessions. Hence, the front-ends must ensure that requests to several etherpad items must be performed sequentially (i.e. a next request can only be sent when the previous response was received)

---

Pad deletion and copy are implemented on hooks:

> Note: the event hooks may be removed in the future. Make sure to update the code and this documentation.

### Delete an etherpad on deletion of its item

```mermaid
sequenceDiagram
    Note over Graasp back-end: Item deletion event <br> check if item type is etherpad
    Graasp back-end ->> Etherpad server: deletePad <br> { padID }
```

### Copy an etherpad on copy of its item

```mermaid
sequenceDiagram
    Note over Graasp back-end: Item copy event <br> check if item type is etherpad
    Note over Graasp back-end: Generate unique <br> { padName }
    Graasp back-end ->> Etherpad server: createGroupIfNotExistsFor <br> { groupMapper: padName }
    Etherpad server ->> Graasp back-end:  { groupID }
    Graasp back-end ->> Etherpad server: copyPad <br> { source: padID, destination: { groupID, padName } }
    Etherpad server ->> Graasp back-end: ok
    Note over Graasp back-end: Mutate item copy with new <br> { groupID, padName }  <br> before persisting
```

## Testing

This plugin provides some testing utilities for unit tests. The file [test/api.ts](test/api.ts) provides a [nock](https://github.com/nock/nock) interceptor to emulate HTTP responses from the Etherpad server that is typed against the Etherpad HTTP API library. It also provides the outgoing search parameters that are sent to the Etherpad server.

Example usage:

```ts
it('example test', () => {
  // First set up the API responses that your test case expects
  // The return value is a promise mapping the outbound method name to the associated request search parameters
  const searchParams = setUpApi({
    // Keys are Etherpad HTTP API method names and values are [statusCode, etherpadResponse: { code, message, data }]
    // The response data is automatically typed against the API library
    createGroupIfNotExistsFor: [StatusCodes.OK, { code: 0, message: 'ok', data: { groupID: MOCK_GROUP_ID } }],
    createGroupPad: [StatusCodes.OK, { code: 0, message: 'ok', data: null }],
  });

  // Perform the request
  const result = await app.inject({
    method: 'GET',
    url: '/etherpad/view/id',
  });

  // Note that you must await the search params after the request, otherwise you will block and timeout
  // You can destructure the keys corresponding to the method names above, which values are the searchParams object
  const { createGroupIfNotExistsFor, createGroupPad } = await searchParams;

  // You can then perform assertions on the result and the search parameters
  expect(result.statusCode).toBe(200);
  expect(createGroupIfNotExistsFor?.get('groupMapper')).toBe('foo');
  expect(createGroupPad?.get('groupID')).toBe('bar');
});
```
