import { EntityManager, In } from 'typeorm';

import { ResultOf } from '@graasp/sdk';

import { MutableRepository } from '../../../../../repositories/MutableRepository';
import { DEFAULT_PRIMARY_KEY } from '../../../../../repositories/const';
import { IllegalArgumentException } from '../../../../../repositories/errors';
import { appActionSchema } from '../../../../member/plugins/export-data/schemas/schemas';
import { schemaToSelectMapper } from '../../../../member/plugins/export-data/utils/selection.utils';
import { mapById } from '../../../../utils';
import { ManyItemsGetFilter, SingleItemGetFilter } from '../interfaces/request';
import { AppAction } from './appAction';
import { InputAppAction } from './interfaces/app-action';

type CreateAppActionBody = { appAction: Partial<InputAppAction>; itemId: string; memberId: string };
type UpdateAppActionBody = Partial<Omit<AppAction, 'item'>>;

export class AppActionRepository extends MutableRepository<AppAction, UpdateAppActionBody> {
  constructor(manager?: EntityManager) {
    super(DEFAULT_PRIMARY_KEY, AppAction, manager);
  }

  async addOne({ itemId, memberId, appAction }: CreateAppActionBody) {
    return await super.insert({
      ...appAction,
      item: { id: itemId },
      member: { id: memberId },
    });
  }

  async getOne(id: string) {
    return await super.findOne(id, { relations: { member: true } });
  }

  async getForItem(itemId: string, filters: SingleItemGetFilter) {
    if (!itemId) {
      throw new IllegalArgumentException('The itemId must be defined', this.classEntity);
    }

    const { memberId } = filters;
    return await this.repository.find({
      where: { item: { id: itemId }, member: { id: memberId } },
      relations: { member: true },
    });
  }

  /**
   * Return all the app actions generated by the given member.
   * @param memberId ID of the member to retrieve the data.
   * @returns an array of app actions generated by the member.
   */
  async getForMemberExport(memberId: string) {
    if (!memberId) {
      throw new IllegalArgumentException('The memberId must be defined', this.classEntity);
    }

    return await this.repository.find({
      select: schemaToSelectMapper(appActionSchema),
      where: { member: { id: memberId } },
      order: { createdAt: 'DESC' },
      relations: {
        item: true,
      },
    });
  }

  async getForManyItems(
    itemIds: string[],
    filters: ManyItemsGetFilter,
  ): Promise<ResultOf<AppAction[]>> {
    const { memberId } = filters;

    if (itemIds.length === 0) {
      throw new IllegalArgumentException('The itemIds must not be empty!', this.classEntity);
    }

    // here it is ok to have some app actions where the item or the member are null (because of missing or soft-deleted relations)
    const appActions = await this.repository.find({
      where: { item: { id: In(itemIds) }, member: { id: memberId } },
      relations: { item: true, member: true },
    });
    // todo: should use something like:
    // but this does not work. Maybe related to the placement of the IN ?
    // const appActions = await this.createQueryBuilder('actions')
    //   .innerJoinAndSelect('actions.item', 'item', 'actions.item IN (:...itemIds)', { itemIds })
    //   .innerJoinAndSelect('actions.member', 'member', 'actions.member = :memberId', { memberId })
    //   .getMany();
    return mapById({
      keys: itemIds,
      findElement: (id) => appActions.filter(({ item }) => item.id === id),
    });
  }
}
