import { Brackets, DeepPartial, EntityManager } from 'typeorm';

import { AppDataVisibility, FileItemType, ItemType, Member, PermissionLevel } from '@graasp/sdk';

import { MutableRepository } from '../../../../../repositories/MutableRepository';
import { DEFAULT_PRIMARY_KEY } from '../../../../../repositories/const';
import { appDataSchema } from '../../../../member/plugins/export-data/schemas/schemas';
import { schemaToSelectMapper } from '../../../../member/plugins/export-data/utils/selection.utils';
import { AppData, Filters } from './appData';
import { AppDataNotFound, PreventUpdateAppDataFile } from './errors';
import { InputAppData } from './interfaces/app-data';

type CreateAppDataBody = { appData: Partial<InputAppData>; itemId: string; actorId: Member['id'] };
type UpdateAppDataBody = DeepPartial<InputAppData>;

const RELATIONS = { member: true, creator: true, item: true };

export class AppDataRepository extends MutableRepository<AppData, UpdateAppDataBody> {
  constructor(manager?: EntityManager) {
    super(DEFAULT_PRIMARY_KEY, AppData, manager);
  }

  async addOne({ itemId, actorId, appData }: CreateAppDataBody): Promise<AppData> {
    return await super.insert(
      {
        ...appData,
        item: { id: itemId },
        creator: { id: actorId },
        member: { id: appData.memberId ?? actorId },
      },
      RELATIONS,
    );
  }

  async updateOne(appDataId: string, body: UpdateAppDataBody): Promise<AppData> {
    // we shouldn't update file data
    const originalData = await super.findOne(appDataId);

    if (!originalData) {
      throw new AppDataNotFound(appDataId);
    }

    const dataType = originalData.data?.type as FileItemType;
    if ([ItemType.LOCAL_FILE, ItemType.S3_FILE].includes(dataType)) {
      throw new PreventUpdateAppDataFile(originalData.id);
    }

    return await super.updateOne(appDataId, body);
  }

  async getOne(id: string) {
    return await super.findOne(id, {
      relations: RELATIONS,
    });
  }

  /**
   * Return all the app data generated by the given member.
   * @param memberId ID of the member to retrieve the data.
   * @returns an array of app data generated by the member.
   */
  async getForMemberExport(memberId: string): Promise<AppData[]> {
    super.throwsIfParamIsInvalid('memberId', memberId);

    return await this.repository.find({
      select: schemaToSelectMapper(appDataSchema),
      where: [{ member: { id: memberId } }, { creator: { id: memberId } }],
      order: { updatedAt: 'DESC' },
      relations: {
        item: true,
        member: true,
        creator: true,
      },
    });
  }

  async getForItem(
    itemId: string,
    filters: Filters = {},
    permission?: PermissionLevel,
  ): Promise<AppData[]> {
    const { memberId, type } = filters;

    const query = this.repository
      .createQueryBuilder('appData')
      .leftJoinAndSelect('appData.member', 'member')
      .leftJoinAndSelect('appData.creator', 'creator')
      .leftJoinAndSelect('appData.item', 'item')
      .where('item.id = :itemId', { itemId });

    // filter app data to only include requested type
    if (type) {
      query.andWhere('appData.type = :type', { type });
    }

    // restrict app data access if user is not an admin
    if (permission !== PermissionLevel.Admin) {
      query.andWhere(
        new Brackets((qb1) => {
          // - visibility: item
          qb1.where(`appData.visibility = :v1`, { v1: AppDataVisibility.Item });

          // - visibility: member & member: id
          // additionally get member's app data if defined
          if (memberId) {
            qb1.orWhere(
              new Brackets((qb2) => {
                qb2
                  .where(`appData.visibility = :v2`, { v2: AppDataVisibility.Member })
                  .andWhere('member.id = :memberId', { memberId });
              }),
            );
          }
        }),
      );
    }

    return await query.getMany();
  }
}
