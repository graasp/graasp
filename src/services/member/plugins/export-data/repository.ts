import { desc, eq } from 'drizzle-orm/sql';

import { DBConnection } from '../../../../drizzle/db';
import { ItemMembership, itemBookmarks } from '../../../../drizzle/schema';
import { throwsIfParamIsInvalid } from '../../../../repositories/utils';
import { MemberIdentifierNotFound } from '../../../itemLogin/errors';

export class ExportDataRepository {
  /**
   * Return all the items where the creator is the given actor.
   * It even returns the item if the actor is the creator but without permissions on it !
   *
   * @param memberId The creator of the items.
   * @returns an array of items created by the actor.
   */
  async getItems(db: DBConnection, memberId: string) {
    if (!memberId) {
      throw new MemberIdentifierNotFound();
    }

    return this.repository.find({
      select: schemaToSelectMapper(itemSchema),
      where: { creator: { id: memberId } },
      order: { updatedAt: 'DESC' },
      relations: {
        creator: true,
      },
    });
  }

  /**
   * Return all the memberships related to the given account.
   * @param accountId ID of the account to retrieve the data.
   * @returns an array of memberships.
   */
  async getItemMemberships(
    db: DBConnection,
    accountId: string,
  ): Promise<ItemMembership[]> {
    if (!accountId) {
      throw new MemberIdentifierNotFound();
    }

    return this.repository.find({
      select: schemaToSelectMapper(itemMembershipSchema),
      where: { account: { id: accountId } },
      order: { updatedAt: 'DESC' },
      relations: {
        item: true,
      },
    });
  }

  /**
   * Return all the chat mentions for the given account.
   * @param accountId ID of the account to retrieve the data.
   * @returns an array of the chat mentions.
   */
  async getChatMentions(
    db: DBConnection,
    accountId: string,
  ): Promise<ChatMention[]> {
    if (!accountId) {
      throw new NoChatMentionForMember({ accountId });
    }

    return this.repository.find({
      select: schemaToSelectMapper(messageMentionSchema),
      where: { account: { id: accountId } },
      order: { createdAt: 'DESC' },
      relations: {
        message: {
          creator: true,
        },
      },
    });
  }

  /**
   * Return all the messages related to the given member.
   * @param memberId ID of the member to retrieve the data.
   * @returns an array of the messages.
   */
  async getChatMessages(
    db: DBConnection,
    memberId: string,
  ): Promise<ChatMessage[]> {
    throwsIfParamIsInvalid('memberId', memberId);

    return await this.repository.find({
      select: schemaToSelectMapper(messageSchema),
      where: { creator: { id: memberId } },
      order: { createdAt: 'DESC' },
      relations: {
        item: true,
      },
    });
  }

  /**
   * Return all the actions generated by the given account.
   * @param accountId ID of the account to retrieve the data.
   * @returns an array of actions generated by the account.
   */
  async getActions(db: DBConnection, accountId: string): Promise<Action[]> {
    if (!accountId) {
      throw new MemberIdentifierNotFound();
    }

    return this.repository.find({
      select: schemaToSelectMapper(actionSchema),
      where: { account: { id: accountId } },
      order: { createdAt: 'DESC' },
      relations: {
        item: true,
      },
    });
  }

  /**
   * Return all the app actions generated by the given account.
   * @param accountId ID of the account to retrieve the data.
   * @returns an array of app actions generated by the account.
   */
  async getAppActions(db: DBConnection, accountId: string) {
    if (!accountId) {
      throw new IllegalArgumentException('The accountId must be defined');
    }

    return await this.repository.find({
      select: schemaToSelectMapper(appActionSchema),
      where: { account: { id: accountId } },
      order: { createdAt: 'DESC' },
      relations: {
        item: true,
      },
    });
  }

  /**
   * Return all the app data generated by the given account.
   * @param accountId ID of the account to retrieve the data.
   * @returns an array of app data generated by the account.
   */
  async getAppData(db: DBConnection, accountId: string): Promise<AppData[]> {
    super.throwsIfParamIsInvalid('accountId', accountId);

    return await this.repository.find({
      select: schemaToSelectMapper(appDataSchema),
      where: [{ account: { id: accountId } }, { creator: { id: accountId } }],
      order: { updatedAt: 'DESC' },
      relations: {
        item: true,
        account: true,
        creator: true,
      },
    });
  }
  /**
   * Return all the app settings generated by the given member.
   * @param memberId ID of the member to retrieve the data.
   * @returns an array of app settings generated by the member.
   */
  async getAppSettings(
    db: DBConnection,
    memberId: string,
  ): Promise<AppSetting[]> {
    if (!memberId) {
      throw new MemberIdentifierNotFound();
    }

    return await this.repository.find({
      select: schemaToSelectMapper(appSettingSchema),
      where: { creator: { id: memberId } },
      order: { updatedAt: 'DESC' },
      relations: {
        item: true,
      },
    });
  }

  /**
   * Return all the favorite items of the given member.
   * @param memberId ID of the member to retrieve the data.
   * @returns an array of favorites.
   */
  async getItemBookmarks(
    db: DBConnection,
    memberId: string,
  ): Promise<
    {
      id: string;
      createdAt: string;
      itemId: string;
    }[]
  > {
    if (!memberId) {
      throw new MemberIdentifierNotFound();
    }
    const result = await db.query.itemBookmarks.findMany({
      columns: { id: true, createdAt: true, itemId: true },
      where: eq(itemBookmarks.memberId, memberId),
      orderBy: desc(itemBookmarks.createdAt),
    });

    return result;
  }

  /**
   * Return all the likes created by the given member.
   * @param creatorId ID of the member to retrieve the data.
   * @returns an array of item likes.
   */
  async getByCreatorToExport(
    db: DBConnection,
    creatorId: CreatorId,
  ): Promise<ItemLike[]> {
    throwsIfParamIsInvalid('creatorId', creatorId);

    return await this.repository.find({
      select: schemaToSelectMapper(itemLikeSchema),
      where: { creator: { id: creatorId } },
      order: { createdAt: 'DESC' },
      relations: {
        item: true,
      },
    });
  }
}
