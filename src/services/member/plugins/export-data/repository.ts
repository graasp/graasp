import { or } from 'drizzle-orm';
import { desc, eq } from 'drizzle-orm/sql';
import { singleton } from 'tsyringe';

import { UUID } from '@graasp/sdk';

import { DBConnection } from '../../../../drizzle/db';
import {
  actionsTable,
  appActions,
  appDatas,
  appSettings,
  chatMentionsTable,
  chatMessagesTable,
  itemBookmarks,
  itemLikes,
  itemMemberships,
  itemsRaw,
} from '../../../../drizzle/schema';
import {
  ActionWithItem,
  AppActionWithItem,
  AppDataWithItem,
  AppSettingWithItem,
  ChatMentionWithMessage,
  ChatMessageWithItem,
  Item,
  ItemLikeWithItem,
  ItemMembershipWithItem,
} from '../../../../drizzle/types';
import { IllegalArgumentException } from '../../../../repositories/errors';
import { throwsIfParamIsInvalid } from '../../../../repositories/utils';
import { MaybeUser } from '../../../../types';
import { filterOutItems } from '../../../authorization.utils';
import { NoChatMentionForMember } from '../../../chat/errors';
import { ItemVisibilityRepository } from '../../../item/plugins/itemVisibility/repository';
import { ItemService } from '../../../item/service';
import { MemberIdentifierNotFound } from '../../../itemLogin/errors';
import { ItemMembershipRepository } from '../../../itemMembership/repository';

@singleton()
export class ExportDataRepository {
  private readonly itemService: ItemService;
  private readonly itemVisibilityRepository: ItemVisibilityRepository;
  private readonly itemMembershipRepository: ItemMembershipRepository;

  constructor(
    itemService: ItemService,
    itemMembershipRepository: ItemMembershipRepository,
    itemVisibilityRepository: ItemVisibilityRepository,
  ) {
    this.itemService = itemService;
    this.itemMembershipRepository = itemMembershipRepository;
    this.itemVisibilityRepository = itemVisibilityRepository;
  }

  /**
   * Return all the items where the creator is the given actor.
   * It even returns the item if the actor is the creator but without permissions on it !
   *
   * @param memberId The creator of the items.
   * @returns an array of items created by the actor.
   */
  async getItems(db: DBConnection, memberId: string): Promise<Item[]> {
    if (!memberId) {
      throw new MemberIdentifierNotFound();
    }

    return db.query.itemsRaw.findMany({
      where: eq(itemsRaw.creatorId, memberId),
      orderBy: desc(itemsRaw.updatedAt),
    });
  }

  async getFilteredDescendants(db: DBConnection, account: MaybeUser, itemId: UUID) {
    const { descendants } = await this.itemService.getDescendants(db, account, itemId);
    if (!descendants.length) {
      return [];
    }
    // TODO optimize?
    return filterOutItems(
      db,
      account,
      {
        itemMembershipRepository: this.itemMembershipRepository,
        itemVisibilityRepository: this.itemVisibilityRepository,
      },
      descendants,
    );
  }

  /**
   * Return all the memberships related to the given account.
   * @param accountId ID of the account to retrieve the data.
   * @returns an array of memberships.
   */
  async getItemMemberships(db: DBConnection, accountId: string): Promise<ItemMembershipWithItem[]> {
    if (!accountId) {
      throw new MemberIdentifierNotFound();
    }

    return await db.query.itemMemberships.findMany({
      where: eq(itemMemberships.accountId, accountId),
      orderBy: desc(itemMemberships.updatedAt),
      with: {
        item: true,
      },
    });
  }

  /**
   * Return all the chat mentions for the given account.
   * @param accountId ID of the account to retrieve the data.
   * @returns an array of the chat mentions.
   */
  async getChatMentions(db: DBConnection, accountId: string): Promise<ChatMentionWithMessage[]> {
    if (!accountId) {
      throw new NoChatMentionForMember({ accountId });
    }

    return await db.query.chatMentionsTable.findMany({
      // columns:{}
      where: eq(chatMentionsTable.accountId, accountId),
      orderBy: desc(chatMentionsTable.createdAt),
      with: {
        message: true,
      },
    });
  }

  /**
   * Return all the messages related to the given member.
   * @param memberId ID of the member to retrieve the data.
   * @returns an array of the messages.
   */
  async getChatMessages(db: DBConnection, memberId: string): Promise<ChatMessageWithItem[]> {
    throwsIfParamIsInvalid('memberId', memberId);

    return await db.query.chatMessagesTable.findMany({
      // select: schemaToSelectMapper(messageSchema),
      where: eq(chatMessagesTable.creatorId, memberId),
      orderBy: desc(chatMessagesTable.createdAt),
      with: {
        item: true,
      },
    });
  }

  /**
   * Return all the actions generated by the given account.
   * @param accountId ID of the account to retrieve the data.
   * @returns an array of actions generated by the account.
   */
  async getActions(db: DBConnection, accountId: string): Promise<ActionWithItem[]> {
    if (!accountId) {
      throw new MemberIdentifierNotFound();
    }

    return await db.query.actionsTable.findMany({
      // select: schemaToSelectMapper(actionSchema),
      where: eq(actionsTable.accountId, accountId),
      orderBy: desc(actionsTable.createdAt),
      with: {
        item: true,
      },
    });
  }

  /**
   * Return all the app actions generated by the given account.
   * @param accountId ID of the account to retrieve the data.
   * @returns an array of app actions generated by the account.
   */
  async getAppActions(db: DBConnection, accountId: string): Promise<AppActionWithItem[]> {
    if (!accountId) {
      throw new IllegalArgumentException('The accountId must be defined');
    }

    return await db.query.appActions.findMany({
      // select: schemaToSelectMapper(actionSchema),
      where: eq(appActions.accountId, accountId),
      orderBy: desc(appActions.createdAt),
      with: {
        item: true,
      },
    });
  }

  /**
   * Return all the app data generated by the given account.
   * @param accountId ID of the account to retrieve the data.
   * @returns an array of app data generated by the account.
   */
  async getAppData(db: DBConnection, accountId: string): Promise<AppDataWithItem[]> {
    if (!accountId) {
      throw new IllegalArgumentException('The accountId must be defined');
    }

    return await db.query.appDatas.findMany({
      where: or(eq(appDatas.accountId, accountId), eq(appDatas.creatorId, accountId)),
      orderBy: desc(appDatas.createdAt),
      with: {
        item: true,
      },
    });
  }
  /**
   * Return all the app settings generated by the given member.
   * @param memberId ID of the member to retrieve the data.
   * @returns an array of app settings generated by the member.
   */
  async getAppSettings(db: DBConnection, memberId: string): Promise<AppSettingWithItem[]> {
    if (!memberId) {
      throw new MemberIdentifierNotFound();
    }

    return await db.query.appSettings.findMany({
      where: eq(appSettings.creatorId, memberId),
      orderBy: desc(appSettings.createdAt),
      with: {
        item: true,
      },
    });
  }

  /**
   * Return all the favorite items of the given member.
   * @param memberId ID of the member to retrieve the data.
   * @returns an array of favorites.
   */
  async getItemBookmarks(
    db: DBConnection,
    memberId: string,
  ): Promise<
    {
      id: string;
      createdAt: string;
      itemId: string;
    }[]
  > {
    if (!memberId) {
      throw new MemberIdentifierNotFound();
    }
    const result = await db.query.itemBookmarks.findMany({
      columns: { id: true, createdAt: true, itemId: true },
      where: eq(itemBookmarks.memberId, memberId),
      orderBy: desc(itemBookmarks.createdAt),
    });

    return result;
  }

  /**
   * Return all the likes created by the given member.
   * @param creatorId ID of the member to retrieve the data.
   * @returns an array of item likes.
   */
  async getByCreatorToExport(db: DBConnection, creatorId: string): Promise<ItemLikeWithItem[]> {
    throwsIfParamIsInvalid('creatorId', creatorId);

    return await db.query.itemLikes.findMany({
      where: eq(itemLikes.creatorId, creatorId),
      orderBy: desc(itemLikes.createdAt),
      with: {
        item: true,
      },
    });
  }
}
